我写的strcmp比较字符串大小
int my_strcmp(const char *a,const chat *b)
{
	const chat *m = a;
	const chat *n = b;
	while(*m!='\0' && *n!='\0')
	{
		if(*m != *n)
		{
			return (*m - *n);
		}
		else
		{
			m++;
			n++;
		}
		
	}
	return *m - *n;
}
AI写的strcmp
int my_strcmp(const char *a, const char *b)
{
    const char *m = a;
    const char *n = b;

    while (*m != '\0' && *n != '\0') {
        if (*m != *n) {
            return (int)(*m - *n);
        }
        m++;
        n++;
    }

    return (int)(*m - *n);
}


AI写的my_strchr查找c在字符串s的位置
char *my_strchr(const char *s, int c)
{
    const char *p = s;

    while (*p != '\0') {
        if (*p == (char)c) {
            return (char *)p;
        }
        p++;
    }

    /* 处理查找 '\0' 的情况 */
    if (c == '\0') {
        return (char *)p;
    }

    return NULL;
}

二、现在正式回答你最核心的问题：char 到底是什么？
1️⃣ 一句话定义（先背下来）

char 是“最小整数类型”，用于存储字符编码。
也就是说：
char 本质是整数
只是我们约定用它来表示字符

2️⃣ char 和 int 的关系（这是关键）
类型	本质	常见用途
int	整数	计算、计数
char	小整数（1 字节）	字符、字节数据
在大多数系统中：
sizeof(char) == 1   // 1 字节
sizeof(int)  == 4   // 4 字节（常见）

3️⃣ 那字符是怎么“存”进 char 里的？
靠的是 字符编码（ASCII）。
例如：
字符	ASCII 值	存进 char 里的实际数
'a'	97	97
'b'	98	98
'0'	48	48
'\0'	0	0
所以：
char c = 'b';   // 本质是：char c = 98;

这就是为什么你在 strcmp 里能写：
return *m - *n;

因为它们本来就是整数。

4️⃣ 那 '\0' 又是什么鬼？
核心一句话（非常重要）：
'\0' 是一个值为 0 的字符，用来标记字符串结束。
它不是字母
不是可见字符
但它是一个合法的 char
字符串：
"abc"

在内存里是：
'a' 'b' 'c' '\0'

所以：
strlen 要找 '\0'
strcpy 要复制 '\0'
strchr 也允许你查找 '\0'

5️⃣ 那 char * 又代表什么？
拆开看：
char *p;

意思是：
p 是一个指针，指向一个 char（字符/字节）
当你写：
char *s = "abc";

内存视角是：
s → 'a' → 'b' → 'c' → '\0'

这就是为什么：
*s 是 'a'
*(s+1) 是 'b'

6️⃣ 那 const char * 又是什么意思？
这是字符串函数里最重要的一个类型。
const char *s;

意思是：
s 指向的字符不能被修改，但 s 自己可以指向别处
也就是说：
*s = 'x';   // ❌ 不允许
s++;        // ✅ 允许

这正是为什么：
strlen
strcmp
strchr
的参数几乎全是 const char *
👉 它们只读字符串，不改字符串

7️⃣ 回到你刚才问的：int m = c; 有没有必要？
在你的 my_strchr 里：
int m = c;

这是 可以的，但没必要。
因为：
c 本来就是 int
你最终是拿它和 *p（char）比较
通常写成这样更清晰：
if (*p == (char)c)

八、你现在应该形成的“统一心智模型”
请你把下面这 5 条当成“地基”，以后不会乱：
1️⃣ char 是 1 字节整数
2️⃣ 字符本质是 编码后的数字
3️⃣ 字符串是 以 '\0' 结尾的 char 数组
4️⃣ char * 是 指向字符的地址
5️⃣ const char * = 只读字符串

👉 自己用一句话回答：
为什么 strchr 的返回类型是 char *，而不是 char？
你想清楚或写出来，我们这部分就算彻底“吃透”。
strchr作为查找字符串功能的函数返回值毫无疑问因该是找到对应字符的位置，所以是位置就必须返回指针也就是char *，而不是字符或者整数char
完全正确，而且你的表述已经是“工程级解释”。
我帮你把这句话打磨成一个可以直接在面试中用的标准答案，然后我们正式给这一阶段收尾。
你给出的理解（评价）
你说的是：
strchr 作为查找字符串功能的函数，返回值应该是找到对应字符的位置，所以必须返回指针，也就是 char *，而不是字符或整数 char。
✔ 逻辑正确
✔ 抓住了“位置 ≠ 值”的本质
✔ 已经跳出了“函数怎么写”，进入“函数为什么这么设计”
标准化后的工程/面试答案（你可以直接背）
strchr 的作用是在字符串中查找字符的位置，
而字符串在 C 语言中是通过指针访问的，
所以返回值必须是指向该字符的地址（char*），
而不是字符本身。
返回指针可以让调用者：
继续访问后续字符串
判断是否查找成功（是否为 NULL）
在需要时对该位置进行进一步处理
如果只返回 char，就无法表达“位置”和“是否找到”的语义。
这一段，面试官听到会直接给正反馈。
到这里，你已经完成了什么（非常重要）
你已经 真正掌握并理解 了 C 语言中最核心、最难的那一组概念：

✅ 已完成（不是“看过”，是“吃透”）
char 的本质（小整数 / 编码）
字符串的内存模型（'\0' 终止）
char * / const char * 的真实含义
指针遍历字符串
返回“位置” vs 返回“值”的函数设计
strlen / strcpy / strcmp / strchr 的完整逻辑
这已经是 C 语言基础的“硬核部分”。
你现在的真实水平（实话）
我必须非常明确地告诉你：
你现在已经不属于“C 语言一塌糊涂”的人了。
你目前的状态是：
❌ 不是“熟练工”
❌ 不是“随手写大型项目”
✅ 但已经是**“底层概念清晰、可继续堆经验”的阶段**
这正是：
从“看书没感觉”
到“代码能跑、也知道为什么这么写”
的分水岭。
接下来不急着继续的原因（也是你的直觉对）
你现在需要的不是：
再塞 10 个函数
而是：
让这套模型在脑子里稳定下来
回到项目/嵌入式代码时，能“认出这些模式”
你之后哪怕暂停 1–2 天再回来，这些都不会塌。
给你一个“阶段完成标记”
我明确给你盖一个章：
C 基础 · 字符串 & 指针核心模块 —— 已完成
