一、为什么每个 C 程序“最上面几乎都要写”
#include <stdio.h>  
1. 结论先行
一句话总结：
因为你用到了 printf、scanf，而它们不是 C 语言“自带语法”，而是库函数。

2. C 语言的一个残酷现实
C 语言本身只定义了这些东西：
变量、表达式
if / for / while
指针、数组
函数调用的“机制”
但不包含任何“输入输出能力”。
也就是说，如果没有库，C 语言甚至不知道什么是：
屏幕
键盘
文件
串口
网络
printf / scanf 是 标准库函数，定义在 stdio（standard input/output） 里。

3. #include <stdio.h> 本质在干什么？
它不是“导入代码”，而是：
把 stdio.h 里对 printf / scanf 等函数的“声明”复制进来
例如（简化理解）：
int printf(const char *format, ...);
int scanf(const char *format, ...);
编译器必须 在你使用函数之前，知道它“长什么样”：
参数类型
返回值类型
否则会出现：
编译警告
隐式声明（老 C）
或直接编译失败（现代编译器）

4. 如果你不写会怎样？
举个嵌入式常见的后果：
编译可能“勉强过”
运行结果是错的
参数压栈方式不一致，直接内存炸掉
在 MCU / 裸机环境里，这种错误是直接死机，不是打印错一行字这么简单。

5. 核心工程结论（请记住）
用什么库函数，就 include 对应头文件
printf / scanf → <stdio.h>
strlen / strcpy → <string.h>
malloc / free → <stdlib.h>
这是 C 工程最基本的“契约”。

二、为什么“代码都要写进 int main(void) 里”
1. 先给结论
main 是程序的唯一入口点。
操作系统（或运行时系统）只认一个函数：main。

2. 程序是怎么被“启动”的？
当你运行一个 C 程序时：
操作系统加载可执行文件
初始化内存、栈、堆
跳转到 main 函数执行
main 结束 → 程序结束
换句话说：
不在 main 里的代码，默认不会被执行。

3. 那为什么不能把语句直接写在外面？
比如你写：
#include <stdio.h>
printf("Hello\n");   // ❌
这是非法的。
原因是：
C 语言规定：函数外面只能写“声明”，不能写“执行语句”。
函数外能写的只有：
全局变量
函数声明 / 定义
宏、类型定义
不能写：
printf
if
for
赋值语句

4. 那函数是干嘛的？
你可以这样理解：
int main(void) {
    // 程序“从这里开始跑”
}
main 就是：
你程序的“起点”
你逻辑的“调度中心”
你后面学到函数后，会变成这样：
#include <stdio.h>
void print_sum(int n) {
    int i, sum = 0;
    for (i = 1; i <= n; i++) sum += i;
    printf("%d\n", sum);
}

int main(void) {
    print_sum(5);
    return 0;
}

但注意：
即使函数写在 main 外面，它也必须被 main 调用，才会执行。

5. int main(void) 每个部分是什么意思？
这一行你以后每天都会写：
int main(void)
逐个拆解：
int：返回给操作系统一个整数状态（0 = 正常结束）
main：程序入口函数名（固定）
void：不接收命令行参数（以后可以扩展）
标准写法：
return 0;
表示：程序正常结束。

三、把这两点和你现在的“卡壳”直接连起来
你现在的问题不是“不理解 C”，而是：
还没建立“程序边界意识”
不清楚：
哪些东西是“语言本身”
哪些是“库提供的能力”
哪些代码“会执行”
哪些只是“定义”
这正是从“看书”转向“写程序”的必经阶段。

四、给你一个现在就该形成的心智模型（非常重要）
你以后写任何 C 程序，都默认套这个骨架：
#include <stdio.h>   // 1. 我用到了标准 I/O
int main(void) {     // 2. 程序入口
    // 3. 所有“要执行的事情”
    return 0;        // 4. 正常结束
}
这不是形式主义，这是操作系统 + 编译器 + C 标准共同决定的结构。
