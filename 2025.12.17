第 4 级核心目标（先给你全景）
通过这一关，你要真正理解四件事：
字符串不是新类型，本质是 char 数组
字符串为什么必须以 '\0' 结尾
为什么 sizeof 和 strlen 完全不是一回事
为什么字符串相关 bug 往往是“内存问题”
今天只做 第 1 步 + 第 2 步。

一、先把一句“要命的话”刻进脑子里
C 语言里，没有“字符串”这种数据类型。
你以后看到的：
"hello"
在 C 里，本质是：
{'h','e','l','l','o','\0'}

二、字符串 = char 数组 + 结束标志
1️⃣ 一个最标准的字符串定义
char s[6] = "hello";
等价于：
char s[6] = {'h','e','l','l','o','\0'};
注意两个极其重要的点：
"hello" 占 6 个字节
多出来的那个字节，就是 '\0'

三、为什么一定要有 '\0'？（这是第 4 级的生死问题）
1️⃣ 你先想一个问题
你写过：
printf("%d\n", x);
那 printf("%s", s); 是怎么知道字符串在哪里结束的？
👉 答案：它不知道数组有多长。

2️⃣ C 语言的残酷现实
数组长度 不会自动传递
printf 只拿到了一个地址（char *）
它只能：
从这个地址开始，一个字节一个字节往后读
那它怎么停？

3️⃣ 停止条件只有一个
遇到 '\0'（ASCII 0）
h  e  l  l  o  \0
↑              ↑
开始           停止

4️⃣ 如果没有 '\0' 会发生什么？
这是重点，请你认真看。
假设你写：
char s[5] = {'h','e','l','l','o'};
printf("%s", s);
后果是：
printf 会继续往后读内存
直到 某个未知位置 恰好出现 0
输出内容可能是：
垃圾字符
其他变量内容
直接崩溃（嵌入式中常见）
👉 这是 C 语言中最经典的“越界读”问题

四、你现在必须形成的“字符串模型”
正确模型
字符串 = 起始地址 + 连续字符 + '\0'
错误模型（很多人一辈子都停在这）
字符串 = 一串字符

1) sizeof 的本质
sizeof(s) 返回的是编译期就能确定的存储大小（以字节为单位）。
因为这里 s 是一个数组：char s[] = "hello";，编译器在栈上给它分配了 6 个字节，所以 sizeof(s) 永远是 6。

2) strlen 的本质
strlen(s) 是一个函数，它在运行时做的事情是：
从 s[0] 开始，一个字节一个字节往后扫，直到遇到 '\0'，计数停止。
所以它得到的是“字符串长度”（不含 '\0'）。

3) 一句非常致命但必须牢记的话
strlen 必须依赖 '\0' 才能停下来；如果没有 '\0'，它也会越界读。
