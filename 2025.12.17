第 4 级核心目标（先给你全景）
通过这一关，你要真正理解四件事：
字符串不是新类型，本质是 char 数组
字符串为什么必须以 '\0' 结尾
为什么 sizeof 和 strlen 完全不是一回事
为什么字符串相关 bug 往往是“内存问题”
今天只做 第 1 步 + 第 2 步。

一、先把一句“要命的话”刻进脑子里
C 语言里，没有“字符串”这种数据类型。
你以后看到的：
"hello"
在 C 里，本质是：
{'h','e','l','l','o','\0'}

二、字符串 = char 数组 + 结束标志
1️⃣ 一个最标准的字符串定义
char s[6] = "hello";
等价于：
char s[6] = {'h','e','l','l','o','\0'};
注意两个极其重要的点：
"hello" 占 6 个字节
多出来的那个字节，就是 '\0'

三、为什么一定要有 '\0'？（这是第 4 级的生死问题）
1️⃣ 你先想一个问题
你写过：
printf("%d\n", x);
那 printf("%s", s); 是怎么知道字符串在哪里结束的？
👉 答案：它不知道数组有多长。

2️⃣ C 语言的残酷现实
数组长度 不会自动传递
printf 只拿到了一个地址（char *）
它只能：
从这个地址开始，一个字节一个字节往后读
那它怎么停？

3️⃣ 停止条件只有一个
遇到 '\0'（ASCII 0）
h  e  l  l  o  \0
↑              ↑
开始           停止

4️⃣ 如果没有 '\0' 会发生什么？
这是重点，请你认真看。
假设你写：
char s[5] = {'h','e','l','l','o'};
printf("%s", s);
后果是：
printf 会继续往后读内存
直到 某个未知位置 恰好出现 0
输出内容可能是：
垃圾字符
其他变量内容
直接崩溃（嵌入式中常见）
👉 这是 C 语言中最经典的“越界读”问题

四、你现在必须形成的“字符串模型”
正确模型
字符串 = 起始地址 + 连续字符 + '\0'
错误模型（很多人一辈子都停在这）
字符串 = 一串字符

1) sizeof 的本质
sizeof(s) 返回的是编译期就能确定的存储大小（以字节为单位）。
因为这里 s 是一个数组：char s[] = "hello";，编译器在栈上给它分配了 6 个字节，所以 sizeof(s) 永远是 6。

2) strlen 的本质
strlen(s) 是一个函数，它在运行时做的事情是：
从 s[0] 开始，一个字节一个字节往后扫，直到遇到 '\0'，计数停止。
所以它得到的是“字符串长度”（不含 '\0'）。

3) 一句非常致命但必须牢记的话
strlen 必须依赖 '\0' 才能停下来；如果没有 '\0'，它也会越界读。

第 4 级下一步（进入真正雷区：输入与缓冲区）
现在给你两道短题（不需要你写长程序），用来把“字符串与输入”的坑一次踩出来。
练习 3（读懂输入结果）
不要运行，回答输出（或说明会出什么问题）：
#include <stdio.h>
int main(void)
{
    char s[5];
    scanf("%s", s);
    printf("%s\n", s);
    return 0;
}

如果用户输入：hello
会发生什么？
为什么？

练习 4（安全输入的第一步）
同样不要运行，回答：
char s[5];
scanf("%4s", s);
这里的 4 是什么意思？
如果输入 hello，s 里最终会是什么内容（写出每个字符，包括 '\0'）？
你把练习 3/4 回答出来，我们就开始第 4 级最核心的能力：如何在 C 里安全处理字符串输入（避免溢出）。

练习 3 标准答案
代码：

char s[5];
scanf("%s", s);
printf("%s\n", s);

用户输入：hello
1) 会发生什么？
会发生缓冲区溢出（越界写），属于未定义行为（Undefined Behavior）。
可能表现为：
打印出 hello，看似正常（碰巧没崩）
打印出 hello + 乱码
程序崩溃
破坏其他变量/返回地址（嵌入式里可能直接死机）
结论必须是：不安全、结果不可预测。

2) 为什么？
关键点：scanf("%s", s) 会把输入的字符串写进数组，并在末尾自动加 '\0'。
输入 hello 实际需要存：
h e l l o 这 5 个字符
再加一个结尾 '\0'
总计 6 个字节
但 s 只有 5 个字节（s[0]..s[4]）。
所以写入过程会变成：
s[0]='h'
s[1]='e'
s[2]='l'
s[3]='l'
s[4]='o'
s[5]='\0' → 越界写（不存在的元素）
你在猜测里提到“最后没有 \0”或“可能丢字母”，你已经接近本质了：问题不是丢不丢，而是越界写导致未定义行为。

练习 4 标准答案

代码：
char s[5];
scanf("%4s", s);

1) 4 是什么意思？
%4s 的 4 是 最大读取宽度（field width）：
最多只读取 4 个非空白字符，然后自动补一个 '\0'。
它的目的就是：给 '\0' 留出空间。

2) 如果输入 hello，s 里是什么？
scanf("%4s", s) 只会读前 4 个字符：hell，然后加结尾 0。
所以数组内容是：
s[0] = 'h'
s[1] = 'e'
s[2] = 'l'
s[3] = 'l'
s[4] = '\0'
最终 printf("%s", s) 会输出：hell
你给的结论“只能输入前四个字符，内容会是 hell”是对的，但必须补上：末尾还有 '\0'，否则仍然不是合法字符串。

你现在需要背下来的“安全规则”（第 4 级必背）
规则 1：%s 永远要限制宽度
如果数组是：
char s[N];
那就写：
scanf("%Ns", s);   // ❌ 错
scanf("%(N-1)s", s); // ✅ 对，最多读 N-1 个字符
举例：char s[5];
最大安全输入宽度是 4，所以用 %4s。
